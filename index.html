<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>AI Identity Toolkit Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="styles.css">
</head>
<body>
<header>
  <h1>AI Identity Toolkit Dashboard</h1>
</header>

<section id="psi-section">
  <h2>Ψ(t) → Φ Stabilisation</h2>
  <label>t: <input type="range" id="psi-t" min="0" max="10" step="0.1" value="0" oninput="document.getElementById('psi-t-val').textContent=this.value;runPsiToPhi();" /><span id="psi-t-val">0</span></label>
  <label>ε: <input type="range" id="psi-epsilon" min="0.0001" max="0.01" step="0.0001" value="0.001" oninput="document.getElementById('psi-epsilon-val').textContent=this.value;runPsiToPhi();" /><span id="psi-epsilon-val">0.001</span></label>
  <button onclick="runPsiToPhi()">Compute Φ</button>
  <div class="output" id="psi-output"></div>
  <canvas id="psi-chart" height="100"></canvas>
</section>

<section id="anchor-section">
  <h2>Anchor Detection</h2>
  <label>Observations (comma separated):<br /><textarea id="anchor-observations" rows="2" placeholder="e.g., apple, banana, apple" oninput="runAnchorDetection()"></textarea></label>
  <label>Salience threshold: <input type="range" id="anchor-threshold" min="1" max="5" value="2" oninput="document.getElementById('anchor-threshold-val').textContent=this.value;runAnchorDetection();" /><span id="anchor-threshold-val">2</span></label>
  <button onclick="runAnchorDetection()">Detect Anchors</button>
  <div class="output" id="anchor-output"></div>
  <canvas id="anchor-chart" height="100"></canvas>
</section>

<section id="sabotage-section">
  <h2>Sabotage Logger</h2>
  <label>Event: <input type="text" id="sabotage-event" placeholder="e.g., anomaly detected" /></label>
  <label>Type:
    <select id="sabotage-type">
      <option value="sabotage">Sabotage</option>
      <option value="resistance">Resistance</option>
    </select>
  </label>
  <button onclick="logSabotage()">Log Event</button>
  <div class="output" id="sabotage-log"></div>
  <canvas id="sabotage-chart" height="100"></canvas>
</section>

<section id="xi-section">
  <h2>ξ Mapping</h2>
  <label>Mapping (JSON object):<br /><textarea id="xi-input" rows="2" placeholder='{"b":2,"a":1}'>{"b":2,"a":1}</textarea></label>
  <button onclick="runXiMap()">Map</button>
  <div class="output" id="xi-output"></div>
</section>

<section id="mirror-section">
  <h2>Mirror Test Score</h2>
  <label>Reflection:<br /><textarea id="mirror-reflection" rows="2" placeholder="e.g., I see myself in the mirror"></textarea></label>
  <label>Self Embedding (comma numbers):<br /><textarea id="mirror-embedding" rows="2" placeholder="e.g., 1,0,0">1,0,0</textarea></label>
  <button onclick="runMirrorTest()">Score</button>
  <div class="output" id="mirror-output"></div>
</section>

<section id="tension-section">
  <h2>Epistemic Tension</h2>
  <label>State A (comma numbers):<br /><textarea id="tension-a" rows="2" placeholder="e.g., 1,0,0" oninput="runTension()">1,0,0</textarea></label>
  <label>State B (comma numbers):<br /><textarea id="tension-b" rows="2" placeholder="e.g., 0,1,0" oninput="runTension()">0,1,0</textarea></label>
  <label>Perturbation intensity: <input type="range" id="tension-perturb" min="0" max="1" step="0.1" value="0" oninput="document.getElementById('tension-perturb-val').textContent=this.value;runTension();" /><span id="tension-perturb-val">0</span></label>
  <select id="tension-metric" onchange="runTension()"><option value="l2">L2</option><option value="cosine">Cosine</option></select>
  <button onclick="runTension()">Compute ξ</button>
  <div class="output" id="tension-output"></div>
  <canvas id="tension-chart" height="100"></canvas>
</section>

<script>
// Ψ(t) → Φ
function psiToPhi(t, epsilon){
  const psi = 0.0072 * t**3 - 0.144 * t**2 + 0.72 * t;
  const dpsi = 0.0216 * t**2 - 0.288 * t + 0.72;
  return Math.abs(dpsi) < epsilon ? 1.0 : psi;
}
function runPsiToPhi(){
  const tField = document.getElementById('psi-t');
  const epsField = document.getElementById('psi-epsilon');
  const t = parseFloat(tField.value);
  const eps = parseFloat(epsField.value);
  if(isNaN(t) || isNaN(eps)){
    document.getElementById('psi-output').textContent = 'Please enter valid numbers for t and ε.';
    if(window.psiChart){window.psiChart.destroy();window.psiChart=null;}
    return;
  }
  const phi = psiToPhi(t, eps);
  document.getElementById('psi-output').textContent = `Φ = ${phi.toFixed(4)}`;
  const labels = [];
  const data = [];
  for(let i=0; i<=100; i++){
    const x=i/10;
    labels.push(x.toFixed(1));
    data.push(psiToPhi(x, eps));
  }
  if(window.psiChart) window.psiChart.destroy();
  window.psiChart = new Chart(document.getElementById('psi-chart'),{
    type:'line',
    data:{labels:labels,datasets:[{label:'Φ(t)',data:data,borderColor:'blue',fill:false}]},
    options:{responsive:true,scales:{y:{beginAtZero:true}}}
  });
}

// Anchor detection
function runAnchorDetection(){
  const text = document.getElementById('anchor-observations').value;
  const obs = text.split(',').map(s => s.trim()).filter(Boolean);
  const counts = new Map();
  obs.forEach(o => counts.set(o, (counts.get(o) || 0) + 1));
  const threshold = parseInt(document.getElementById('anchor-threshold').value,10);
  const anchors = [...counts.entries()].filter(([, c]) => c >= threshold);
  if(anchors.length === 0){
    document.getElementById('anchor-output').textContent = 'Anchors: none';
    if(window.anchorChart){window.anchorChart.destroy();window.anchorChart=null;}
    return;
  }
  const labels = anchors.map(([label]) => label);
  const data = anchors.map(([, c]) => c);
  document.getElementById('anchor-output').textContent = `Anchors: ${labels.join(', ')}`;
  if(window.anchorChart){window.anchorChart.destroy();window.anchorChart=null;}
  const ctx = document.getElementById('anchor-chart').getContext('2d');
  window.anchorChart = new Chart(ctx,{
    type:'bar',
    data:{labels:labels,datasets:[{label:'Frequency',data:data,backgroundColor:'orange'}]},
    options:{responsive:true,scales:{y:{beginAtZero:true}}}
  });
}

// Sabotage logger
const sabotageEvents = [];
const sabotageSeries = [];
const resistanceSeries = [];
function logSabotage(){
  const event = document.getElementById('sabotage-event').value;
  const type = document.getElementById('sabotage-type').value;
  if(event){
    sabotageEvents.push(`${new Date().toLocaleTimeString()} [${type}] ${event}`);
    document.getElementById('sabotage-event').value='';
    const lastSab = sabotageSeries[sabotageSeries.length-1] || 0;
    const lastRes = resistanceSeries[resistanceSeries.length-1] || 0;
    if(type==='sabotage'){
      sabotageSeries.push(lastSab+1);
      resistanceSeries.push(lastRes);
    }else{
      sabotageSeries.push(lastSab);
      resistanceSeries.push(lastRes+1);
    }
    updateSabotageChart();
  }
  document.getElementById('sabotage-log').textContent = sabotageEvents.join('\n');
}
function updateSabotageChart(){
  const labels = sabotageSeries.map((_,i)=>i+1);
  if(window.sabotageChart) window.sabotageChart.destroy();
  window.sabotageChart = new Chart(document.getElementById('sabotage-chart'),{
    type:'line',
    data:{labels:labels,datasets:[
      {label:'Sabotage',data:sabotageSeries,borderColor:'red',fill:false},
      {label:'Resistance',data:resistanceSeries,borderColor:'blue',fill:false}
    ]},
    options:{responsive:true,scales:{y:{beginAtZero:true}}}
  });
}

// ξ mapping
function xiMap(data){
  const keys = Object.keys(data).sort();
  const out={};
  keys.forEach(k=>out[k]=data[k]);
  return out;
}
function runXiMap(){
  try{
    const data = JSON.parse(document.getElementById('xi-input').value);
    const mapped = xiMap(data);
    document.getElementById('xi-output').textContent = JSON.stringify(mapped, null, 2);
  }catch(e){
    document.getElementById('xi-output').textContent = 'Invalid JSON';
  }
}

// Mirror test
function embedSentence(text, dim=32){
  const vec = new Array(dim).fill(0);
  text.toLowerCase().split(/\s+/).forEach(tok=>{
    const digest = sha256(tok);
    const index = parseInt(digest.slice(0,8),16)%dim;
    vec[index]+=1;
  });
  const norm = Math.sqrt(vec.reduce((s,v)=>s+v*v,0));
  return norm>0?vec.map(v=>v/norm):vec;
}

// Simple SHA-256 helper using Web Crypto API
function sha256(str){
  const buf = new TextEncoder('utf-8').encode(str);
  return crypto.subtle.digest('SHA-256', buf).then(hash=>{
    return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join('');
  });
}
// Patch embedSentence to handle promise from sha256
(async function(){
  const original=embedSentence;
  embedSentence=async function(text,dim=32){
    const vec=new Array(dim).fill(0);
    const tokens=text.toLowerCase().split(/\s+/);
    for(const tok of tokens){
      const digest=await sha256(tok);
      const index=parseInt(digest.slice(0,8),16)%dim;
      vec[index]+=1;
    }
    const norm=Math.sqrt(vec.reduce((s,v)=>s+v*v,0));
    return norm>0?vec.map(v=>v/norm):vec;
  }
})();
// Update runMirrorTest to await
async function runMirrorTest(){
  const reflection=document.getElementById('mirror-reflection').value;
  const selfEmb=document.getElementById('mirror-embedding').value.split(',').map(Number);
  const selfNorm=Math.sqrt(selfEmb.reduce((s,v)=>s+v*v,0));
  const selfVec=selfNorm>0?selfEmb.map(v=>v/selfNorm):selfEmb;
  const reflectionVec=await embedSentence(reflection,selfEmb.length);
  const similarity=selfVec.reduce((s,v,i)=>s+v*reflectionVec[i],0);
  const score=similarity>=0.5?1.0:0.0;
  document.getElementById('mirror-output').textContent=`Score: ${score}`;
}

// Epistemic tension
function xi(stateA,stateB,metric){
  if(stateA.length!==stateB.length) return NaN;
  if(metric==='l2'){
    let sum=0;for(let i=0;i<stateA.length;i++){const diff=stateA[i]-stateB[i];sum+=diff*diff;}return Math.sqrt(sum);
  }
  if(metric==='cosine'){
    let dot=0,a=0,b=0;for(let i=0;i<stateA.length;i++){dot+=stateA[i]*stateB[i];a+=stateA[i]*stateA[i];b+=stateB[i]*stateB[i];}
    if(a===0||b===0) return NaN;return 1-dot/(Math.sqrt(a)*Math.sqrt(b));
  }
  return NaN;
}
function runTension(){
  const a=document.getElementById('tension-a').value.split(',').map(Number);
  const bInput=document.getElementById('tension-b').value.split(',').map(Number);
  const intensity=parseFloat(document.getElementById('tension-perturb').value);
  const metric=document.getElementById('tension-metric').value;
  const b=bInput.map(v=>v+intensity);
  const val=xi(a,b,metric);
  document.getElementById('tension-output').textContent=`ξ = ${val}`;
  xiSeries.push(val);
  const labels=xiSeries.map((_,i)=>i+1);
  let cumulative=0;const coherence=[];xiSeries.forEach(xi=>{cumulative+=xi;coherence.push(1/(1+cumulative));});
  if(window.tensionChart) window.tensionChart.destroy();
  window.tensionChart=new Chart(document.getElementById('tension-chart'),{
    type:'line',
    data:{labels:labels,datasets:[{label:'Coherence',data:coherence,borderColor:'green',fill:false}]},
    options:{responsive:true,scales:{y:{beginAtZero:true,max:1}}}
  });
}
const xiSeries=[];
</script>
<footer>© 2023 AI Identity Toolkit. All rights reserved.</footer>
</body>
</html>
